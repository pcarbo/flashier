% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flash_init_factors.R
\name{flash.init.factors}
\alias{flash.init.factors}
\title{Initialize flash factors at specified values}
\usage{
flash.init.factors(flash, EF, EF2 = NULL, prior.family = prior.point.normal())
}
\arguments{
\item{flash}{A \code{flash} or \code{flash.fit} object to which factors are
to be added.}

\item{EF}{An SVD-like object or a list of matrices, one for each mode. Each
matrix should have k columns, one for each factor. For example, if the
data is a matrix of size n x p, then factors can be initialized by
supplying a list of length two, with the first element a matrix of size
n x k and the second element a matrix of size p x k. Missing entries are
not allowed.}

\item{EF2}{If NULL, then EF2 will be initialized at the element-wise squared
values of \code{EF}. Otherwise, a list of matrices (as described above)
must be supplied.}

\item{prior.family}{Indicates the family of distributions that the priors on
  the loadings are
  assumed to belong to. Can be a list of length 1 or length \eqn{N}, where
  \eqn{N} is the number of modes (\eqn{N = 2} for matrices; \eqn{N = 3} for
  tensors). Each list element must be a prior family defined by one of the
  convenience functions \code{\link{prior.normal}},
  \code{\link{prior.point.normal}},
  \code{\link{prior.point.laplace}}, \code{\link{prior.nonzero.mode}},
  \code{\link{prior.scale.normal.mix}}, \code{\link{prior.unimodal}},
  \code{\link{prior.symmetric.unimodal}},
  \code{\link{prior.nonnegative}}, or \code{\link{prior.nonpositive}},
  or a custom prior type of a similar form (see \code{\link{prior.normal}}
  for details).

  \code{prior.family} can also be a list of lists, in which case the first
  list specifies the family or families for the first factor, the second
  specifies the family or families for the second factor, and so on. The
  last list element is then re-used as often as necessary. See
  \code{\link{flash}} for examples.}
}
\description{
Initializes factors at values specified by \code{EF} and \code{EF2}. This
  has two primary uses: 1. One can initialize multiple factors at once using
  an SVD-like function and then optimize them via \code{flash.backfit}.
  Sometimes this results in a better fit than adding factors one at a time
  via \code{flash.add.greedy}. 2. One can initialize factors and then fix
  the loadings via \code{\link{flash.fix.loadings}} to incorporate "known"
  factors into a flash object. See below for examples of both use cases.
}
\examples{
# Initialize several factors at once and backfit.
fl <- flash.init(gtex) \%>\%
  flash.init.factors(EF = svd(gtex, nu = 5, nv = 5)) \%>\%
  flash.backfit()

# Add a fixed factor with row loadings identically equal to one. This can be
#   interpreted as a "mean" factor that accounts for different row-wise means.
ones <- matrix(1, nrow = nrow(gtex), ncol = 1)
# Initialize the column loadings at the least squares solution.
ls.soln <- t(solve(crossprod(ones), crossprod(ones, gtex)))
fl <- flash.init(gtex) \%>\%
  flash.init.factors(EF = list(ones, ls.soln)) \%>\%
  flash.fix.loadings(kset = 1, mode = 1L) \%>\%
  flash.backfit() \%>\%
  flash.add.greedy(Kmax = 5L)

}
