% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flash_backfit.R
\name{flash.backfit}
\alias{flash.backfit}
\title{Backfit a flash object}
\usage{
flash.backfit(
  flash,
  kset = NULL,
  method = c("extrapolate", "sequential", "dropout", "random", "parallel"),
  warmstart = TRUE,
  conv.crit.fn = calc.obj.diff,
  tol = set.default.tol(flash),
  maxiter = 500,
  verbose.lvl = get.verbose.lvl(flash)
)
}
\arguments{
\item{flash}{A \code{flash} or \code{flash.fit} object.}

\item{kset}{A vector of integers specifying which factors to backfit.
If \code{kset = NULL}, then all existing factors will be backfitted.}

\item{method}{\code{"sequential"} updates each factor in order, one at a
time. \code{"extrapolate"} does the same but uses an acceleration
technique inspired by Ang and Gillis (2019).  Control parameters are
handled via global options and can be set via
\code{options("extrapolate.control") <- control.param}. \code{"dropout"}
is similar to \code{"sequential"}, but stops updating individual factors
once they are no longer changing very much. This saves time, but often
results in incomplete convergence. \code{"random"} updates each factor one
at a time, but re-orders them randomly after each backfit iteration.
\code{"parallel"} does a simultaneous update of all factors. Unlike other
methods, parallel backfits are not guaranteed to yield monotonic increases
in the variational lower bound.
The number of cores used by \code{"parallel"} can be set via the
command \code{options("cl.cores", n.cores)}. The type of multicore
cluster can be set via \code{options("cl.type", type)}. Typically,
\code{cl.type = "FORK"} is more efficient on Unix-likes.}

\item{warmstart}{Whether to "warmstart" backfits by initializing each factor
update at the current value of the fitted prior.}

\item{conv.crit.fn}{The function used to determine whether convergence has
occurred. TODO: details.}

\item{tol}{The convergence tolerance.}

\item{maxiter}{The maximum number of backfitting iterations. An "iteration"
is defined such that all factors in \code{kset} get updated at each
iteration.}

\item{verbose.lvl}{When and how to display progress updates. Set to
\code{0} for none, \code{1} for updates after a factor is added or a
backfit is completed, \code{2} for additional notifications about the
variational lower bound, and \code{3} for updates after every iteration.
Set to \code{-1} to output a single tab-delimited table of values.}
}
\description{
Backfits existing flash factors. Whereas a "greedy" fit optimizes each
  newly added factor in one go without returning to optimize previously
  added factors, a "backfit" updates all existing factors in a cyclical
  fashion.
}
